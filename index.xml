<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gqlgen</title><link>https://gqlgen.com/</link><description>Recent content on gqlgen</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://gqlgen.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Building GraphQL servers in golang</title><link>https://gqlgen.com/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/getting-started/</guid><description>This tutorial will take you through the process of building a GraphQL server with gqlgen that can:
Return a list of todos Create new todos Mark off todos as they are completed You can find the finished code for this tutorial here
Setup Project Create a directory for your project, and initialise it as a Go Module:
$ mkdir gqlgen-todos $ cd gqlgen-todos $ go mod init github.com/[username]/gqlgen-todos $ go get github.</description></item><item><title>How to configure gqlgen using gqlgen.yml</title><link>https://gqlgen.com/config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/config/</guid><description>gqlgen can be configured using a gqlgen.yml file, by default it will be loaded from the current directory, or any parent directory.
Example:
# Where are all the schema files located? globs are supported eg src/**/*.graphqlsschema:- graph/*.graphqls# Where should the generated server code go?exec:filename:graph/generated/generated.gopackage:generated# Enable Apollo federation supportfederation:filename:graph/generated/federation.gopackage:generated# Where should any generated models go?model:filename:graph/model/models_gen.gopackage:model# Where should the resolver implementations go?resolver:layout:follow-schemadir:graphpackage:graphfilename_template:&amp;#34;{name}.resolvers.go&amp;#34;# Optional: turn on use ` + &amp;#34;`&amp;#34; + `gqlgen:&amp;#34;fieldName&amp;#34;` + &amp;#34;`&amp;#34; + ` tags in your models# struct_tag: json# Optional: turn on to use []Thing instead of []*Thing# omit_slice_element_pointers: false# Optional: set to speed up generation time by not performing a final validation pass.</description></item><item><title>Comparing Features of Other Go GraphQL Implementations</title><link>https://gqlgen.com/feature-comparison/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/feature-comparison/</guid><description>gqlgen gophers graphql-go thunder Kind schema first schema first run time types struct first Boilerplate less more more some Docs docs &amp;amp; examples examples examples examples Query 👍 👍 👍 👍 Mutation 👍 🚧 pr 👍 👍 Subscription 👍 🚧 pr 👍 👍 Type Safety 👍 👍 ⛔️ 👍 Type Binding 👍 👍 ⛔️ 👍 Embedding 👍 ⛔️ 🚧 pr ⛔️ Interfaces 👍 👍 👍 ⛔️ is Generated Enums 👍 ⛔️ ⛔️ ⛔️ Generated Inputs 👍 ⛔️ ⛔️ ⛔️ Federation 👍 ⛔️ ⛔️ ⛔️ Opentracing 👍 👍 ⛔️ ✂️pr Hooks for error logging 👍 ⛔️ ⛔️ ⛔️ Dataloading 👍 👍 👍 ⚠️ Concurrency 👍 👍 👍 👍 Custom errors &amp;amp; error.</description></item><item><title>Type-safe GraphQL for Go</title><link>https://gqlgen.com/introduction/</link><pubDate>Sat, 17 Mar 2018 13:06:47 +1100</pubDate><guid>https://gqlgen.com/introduction/</guid><description/></item><item><title/><link>https://gqlgen.com/_introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/_introduction/</guid><description>gqlgen What is gqlgen? gqlgen is a Go library for building GraphQL servers without any fuss. gqlgen is based on a Schema first approach — You get to Define your API using the GraphQL Schema Definition Language. gqlgen prioritizes Type safety — You should never see map[string]interface{} here. gqlgen enables Codegen — We generate the boring bits, so you can focus on building your app quickly. Still not convinced enough to use gqlgen?</description></item><item><title>Using Apollo federation gqlgen</title><link>https://gqlgen.com/recipes/federation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/recipes/federation/</guid><description>In this quick guide we are going to implement the example Apollo Federation server in gqlgen. You can find the finished result in the examples directory.
Enable federation Uncomment federation configuration in your gqlgen.yml
# Uncomment to enable federationfederation:filename:graph/generated/federation.gopackage:generatedCreate the federated servers For each server to be federated we will create a new gqlgen project.
go run github.com/99designs/gqlgen Update the schema to reflect the federated example
typeReview{body:Stringauthor:User@provides(fields:&amp;#34;username&amp;#34;)product:Product}extendtypeUser@key(fields:&amp;#34;id&amp;#34;){id:ID!@externalreviews:[Review]}extendtypeProduct@key(fields:&amp;#34;upc&amp;#34;){upc:String!@externalreviews:[Review]}and regenerate
go run github.</description></item><item><title>Automatic persisted queries</title><link>https://gqlgen.com/reference/apq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/apq/</guid><description>When you work with GraphQL by default your queries are transferred with every request. That can waste significant bandwidth. To avoid that you can use Automatic Persisted Queries (APQ).
With APQ you send only query hash to the server. If hash is not found on a server then client makes a second request to register query hash with original query on a server.
Usage In order to enable Automatic Persisted Queries you need to change your client.</description></item><item><title>Providing authentication details through context</title><link>https://gqlgen.com/recipes/authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/recipes/authentication/</guid><description>We have an app where users are authenticated using a cookie in the HTTP request, and we want to check this authentication status somewhere in our graph. Because GraphQL is transport agnostic we can&amp;rsquo;t assume there will even be an HTTP request, so we need to expose these authentication details to our graph using a middleware.
package auth import ( &amp;#34;database/sql&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;context&amp;#34; ) // A private key for context that only this package can access.</description></item><item><title>Using maps as changesets</title><link>https://gqlgen.com/reference/changesets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/changesets/</guid><description>Occasionally you need to distinguish presence from nil (undefined vs null). In gqlgen we do this using maps:
typeQuery{updateUser(id:ID!,changes:UserChanges!):User}typeUserChanges{name:Stringemail:String}Then in config set the backing type to map[string]interface{}
models:UserChanges:model:&amp;#34;map[string]interface{}&amp;#34;After running go generate you should end up with a resolver that looks like this:
func (r *queryResolver) UpdateUser(ctx context.Context, id int, changes map[string]interface{}) (*User, error) { u := fetchFromDb(id) /// apply the changes saveToDb(u) return u, nil } We often use the mapstructure library to directly apply these changesets directly to the object using reflection:</description></item><item><title>Setting CORS headers using rs/cors for gqlgen</title><link>https://gqlgen.com/recipes/cors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/recipes/cors/</guid><description>Cross-Origin Resource Sharing (CORS) headers are required when your graphql server lives on a different domain to the one your client code is served. You can read more about CORS in the MDN docs.
rs/cors gqlgen doesn&amp;rsquo;t include a CORS implementation, but it is built to work with all standard http middleware. Here we are going to use the fantastic chi and rs/cors to build our server.
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.</description></item><item><title>Optimizing N+1 database queries using Dataloaders</title><link>https://gqlgen.com/reference/dataloaders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/dataloaders/</guid><description>Have you noticed some GraphQL queries end can make hundreds of database queries, often with mostly repeated data? Lets take a look why and how to fix it.
Query Resolution Imagine if you had a simple query like this:
query{todos{users{name}}}and our todo.user resolver looks like this:
func (r *todoResolver) UserRaw(ctx context.Context, obj *model.Todo) (*model.User, error) { res := db.LogAndQuery(r.Conn, &amp;#34;SELECT id, name FROM dataloader_example.user WHERE id = ?&amp;#34;, obj.UserID) defer res.</description></item><item><title>Determining which fields were requested by a query</title><link>https://gqlgen.com/reference/field-collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/field-collection/</guid><description>Often it is useful to know which fields were queried for in a resolver. Having this information can allow a resolver to only fetch the set of fields required from a data source, rather than over-fetching everything and allowing gqlgen to do the rest.
This process is known as Field Collection — gqlgen automatically does this in order to know which fields should be a part of the response payload. The set of collected fields does however depend on the type being resolved.</description></item><item><title>File Upload</title><link>https://gqlgen.com/reference/file-upload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/file-upload/</guid><description>Graphql server has an already built-in Upload scalar to upload files using a multipart request.
It implements the following spec https://github.com/jaydenseric/graphql-multipart-request-spec, that defines an interoperable multipart form field structure for GraphQL requests, used by various file upload client implementations.
To use it you need to add the Upload scalar in your schema, and it will automatically add the marshalling behaviour to Go types.
Configuration There are two specific options that can be configured for uploading files:</description></item><item><title>Using Gin to setup HTTP handlers</title><link>https://gqlgen.com/recipes/gin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/recipes/gin/</guid><description>Gin is an excellent alternative for the net/http router. From their official GitHub page:
Gin is a web framework written in Go (Golang). It features a martini-like API with much better performance, up to 40 times faster thanks to httprouter. If you need performance and good productivity, you will love Gin.
Here are the steps to setup Gin and gqlgen together:
Install Gin:
$ go get github.com/gin-gonic/gin In your router file, define the handlers for the GraphQL and Playground endpoints in two different methods and tie then together in the Gin router:</description></item><item><title>godoc</title><link>https://gqlgen.com/reference/godoc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/godoc/</guid><description/></item><item><title>Sending custom error data in the graphql response</title><link>https://gqlgen.com/reference/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/errors/</guid><description>Returning errors All resolvers simply return an error to be sent to the user. The assumption is that any error message returned here is appropriate for end users. If certain messages aren&amp;rsquo;t safe, customise the error presenter.
Multiple errors To return multiple errors you can call the graphql.Error functions like so:
package foo import ( &amp;#34;context&amp;#34; &amp;#34;github.com/vektah/gqlparser/v2/gqlerror&amp;#34; &amp;#34;github.com/99designs/gqlgen/graphql&amp;#34; ) func (r Query) DoThings(ctx context.Context) (bool, error) { // Print a formatted string graphql.</description></item><item><title>Disabling introspection</title><link>https://gqlgen.com/reference/introspection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/introspection/</guid><description>One of the best features of GraphQL is it&amp;rsquo;s powerful discoverability and its is automatically included when using NewDefaultServer.
Disable introspection for the whole server To opt out of introspection globally you should build your own server with only the features you use. For example a simple server that only does POST, and only has introspection in dev could look like:
srv := handler.New(es) srv.AddTransport(transport.Options{}) srv.AddTransport(transport.POST{}) if os.GetEnv(&amp;#34;ENVIRONMENT&amp;#34;) == &amp;#34;development&amp;#34; { srv.</description></item><item><title>Migrating to 0.11</title><link>https://gqlgen.com/recipes/migration-0.11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/recipes/migration-0.11/</guid><description>Updated gqlparser gqlparser had a breaking change, if you have any references to it in your project your going to need to update them from github.com/vektah/gqlparser to github.com/vektah/gqlparser/v2.
sed -i &amp;#39;s/github.com\/vektah\/gqlparser/github.com\/vektah\/gqlparser\/v2/&amp;#39; $(find -name &amp;#39;*.go&amp;#39;) Handler Refactor The handler package has grown organically for a long time, 0.11 is a large cleanup of the handler package to make it more modular and easier to maintain once we get to 1.0.
Transports Transports are the first thing that run, they handle decoding the incoming http request, and encoding the graphql response.</description></item><item><title>Allowing mutation of generated models before rendering</title><link>https://gqlgen.com/recipes/modelgen-hook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/recipes/modelgen-hook/</guid><description>The following recipe shows how to use a modelgen plugin hook to mutate generated models before they are rendered into a resulting file. This feature has many uses but the example focuses only on inserting ORM-specific tags into generated struct fields. This is a common use case since it allows for better field matching of DB queries and the generated data structure.
First of all, we need to create a function that will mutate the generated model.</description></item><item><title>How to write plugins for gqlgen</title><link>https://gqlgen.com/reference/plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/plugins/</guid><description>Plugins provide a way to hook into the gqlgen code generation lifecycle. In order to use anything other than the default plugins you will need to create your own entrypoint:
Using a plugin // +build ignore package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; &amp;#34;github.com/99designs/gqlgen/api&amp;#34; &amp;#34;github.com/99designs/gqlgen/codegen/config&amp;#34; &amp;#34;github.com/99designs/gqlgen/plugin/stubgen&amp;#34; ) func main() { cfg, err := config.LoadConfigFromDefaultLocations() if err != nil { fmt.Fprintln(os.Stderr, &amp;#34;failed to load config&amp;#34;, err.Error()) os.Exit(2) } err = api.</description></item><item><title>Preventing overly complex queries</title><link>https://gqlgen.com/reference/complexity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/complexity/</guid><description>GraphQL provides a powerful way to query your data, but putting great power in the hands of your API clients also exposes you to a risk of denial of service attacks. You can mitigate that risk with gqlgen by limiting the complexity of the queries you allow.
Expensive Queries Consider a schema that allows listing blog posts. Each blog post is also related to other posts.
typeQuery{posts(count:Int=10):[Post!]!}typePost{title:String!text:String!related(count:Int=10):[Post!]!}It&amp;rsquo;s not too hard to craft a query that will cause a very large response:</description></item><item><title>Resolving graphQL requests</title><link>https://gqlgen.com/reference/resolvers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/resolvers/</guid><description>There are multiple ways that a graphQL type can be bound to a Go struct that allows for many usecases.
Bind directly to struct field names This is the most common use case where the names of the fields on the Go struct match the names of the fields in the graphQL type. If a Go struct field is unexported, it will not be bound to the graphQL type.
type Car struct { Make string Model string Color string OdometerReading int } And then in your graphQL schema:</description></item><item><title>Mapping GraphQL scalar types to Go types</title><link>https://gqlgen.com/reference/scalars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/scalars/</guid><description>Built-in helpers gqlgen ships with some built-in helpers for common custom scalar use-cases, Time, Any, Upload and Map. Adding any of these to a schema will automatically add the marshalling behaviour to Go types.
Time scalarTimeMaps a Time GraphQL scalar to a Go time.Time struct.
Map scalarMapMaps an arbitrary GraphQL value to a map[string]interface{} Go type.
Upload scalarUploadMaps a Upload GraphQL scalar to a graphql.Upload struct, defined as follows:
type Upload struct { File io.</description></item><item><title>Using schema directives to implement permission checks</title><link>https://gqlgen.com/reference/directives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/directives/</guid><description>Directives are a bit like annotations in any other language. They give you a way to specify some behaviour without directly binding to the implementation. This can be really useful for cross cutting concerns like permission checks.
Note: The current directives implementation is still fairly limited, and is designed to cover the most common &amp;ldquo;field middleware&amp;rdquo; case.
Declare it in the schema Directives are declared in your schema, along with all your other types.</description></item></channel></rss>