<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>References on gqlgen</title><link>https://gqlgen.com/reference/</link><description>Recent content in References on gqlgen</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://gqlgen.com/reference/index.xml" rel="self" type="application/rss+xml"/><item><title>Automatic persisted queries</title><link>https://gqlgen.com/reference/apq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/apq/</guid><description>When you work with GraphQL by default your queries are transferred with every request. That can waste significant bandwidth. To avoid that you can use Automatic Persisted Queries (APQ).
With APQ you send only query hash to the server. If hash is not found on a server then client makes a second request to register query hash with original query on a server.
Usage In order to enable Automatic Persisted Queries you need to change your client.</description></item><item><title>Using maps as changesets</title><link>https://gqlgen.com/reference/changesets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/changesets/</guid><description>Occasionally you need to distinguish presence from nil (undefined vs null). In gqlgen we do this using maps:
typeQuery{updateUser(id:ID!,changes:UserChanges!):User}typeUserChanges{name:Stringemail:String}Then in config set the backing type to map[string]interface{}
models:UserChanges:model:&amp;#34;map[string]interface{}&amp;#34;After running go generate you should end up with a resolver that looks like this:
func (r *queryResolver) UpdateUser(ctx context.Context, id int, changes map[string]interface{}) (*User, error) { u := fetchFromDb(id) /// apply the changes saveToDb(u) return u, nil } We often use the mapstructure library to directly apply these changesets directly to the object using reflection:</description></item><item><title>Optimizing N+1 database queries using Dataloaders</title><link>https://gqlgen.com/reference/dataloaders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/dataloaders/</guid><description>Have you noticed some GraphQL queries end can make hundreds of database queries, often with mostly repeated data? Lets take a look why and how to fix it.
Query Resolution Imagine if you had a simple query like this:
query{todos{users{name}}}and our todo.user resolver looks like this:
func (r *todoResolver) UserRaw(ctx context.Context, obj *model.Todo) (*model.User, error) { res := db.LogAndQuery(r.Conn, &amp;#34;SELECT id, name FROM dataloader_example.user WHERE id = ?&amp;#34;, obj.UserID) defer res.</description></item><item><title>Determining which fields were requested by a query</title><link>https://gqlgen.com/reference/field-collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/field-collection/</guid><description>Often it is useful to know which fields were queried for in a resolver. Having this information can allow a resolver to only fetch the set of fields required from a data source, rather than over-fetching everything and allowing gqlgen to do the rest.
This process is known as Field Collection — gqlgen automatically does this in order to know which fields should be a part of the response payload. The set of collected fields does however depend on the type being resolved.</description></item><item><title>File Upload</title><link>https://gqlgen.com/reference/file-upload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/file-upload/</guid><description>Graphql server has an already built-in Upload scalar to upload files using a multipart request.
It implements the following spec https://github.com/jaydenseric/graphql-multipart-request-spec, that defines an interoperable multipart form field structure for GraphQL requests, used by various file upload client implementations.
To use it you need to add the Upload scalar in your schema, and it will automatically add the marshalling behaviour to Go types.
Configuration There are two specific options that can be configured for uploading files:</description></item><item><title>godoc</title><link>https://gqlgen.com/reference/godoc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/godoc/</guid><description/></item><item><title>Sending custom error data in the graphql response</title><link>https://gqlgen.com/reference/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/errors/</guid><description>Returning errors All resolvers simply return an error to be sent to the user. The assumption is that any error message returned here is appropriate for end users. If certain messages aren&amp;rsquo;t safe, customise the error presenter.
Multiple errors To return multiple errors you can call the graphql.Error functions like so:
package foo import ( &amp;#34;context&amp;#34; &amp;#34;github.com/vektah/gqlparser/v2/gqlerror&amp;#34; &amp;#34;github.com/99designs/gqlgen/graphql&amp;#34; ) func (r Query) DoThings(ctx context.Context) (bool, error) { // Print a formatted string graphql.</description></item><item><title>Disabling introspection</title><link>https://gqlgen.com/reference/introspection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/introspection/</guid><description>One of the best features of GraphQL is it&amp;rsquo;s powerful discoverability and its is automatically included when using NewDefaultServer.
Disable introspection for the whole server To opt out of introspection globally you should build your own server with only the features you use. For example a simple server that only does POST, and only has introspection in dev could look like:
srv := handler.New(es) srv.AddTransport(transport.Options{}) srv.AddTransport(transport.POST{}) if os.GetEnv(&amp;#34;ENVIRONMENT&amp;#34;) == &amp;#34;development&amp;#34; { srv.</description></item><item><title>How to write plugins for gqlgen</title><link>https://gqlgen.com/reference/plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/plugins/</guid><description>Plugins provide a way to hook into the gqlgen code generation lifecycle. In order to use anything other than the default plugins you will need to create your own entrypoint:
Using a plugin // +build ignore package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; &amp;#34;github.com/99designs/gqlgen/api&amp;#34; &amp;#34;github.com/99designs/gqlgen/codegen/config&amp;#34; &amp;#34;github.com/99designs/gqlgen/plugin/stubgen&amp;#34; ) func main() { cfg, err := config.LoadConfigFromDefaultLocations() if err != nil { fmt.Fprintln(os.Stderr, &amp;#34;failed to load config&amp;#34;, err.Error()) os.Exit(2) } err = api.</description></item><item><title>Preventing overly complex queries</title><link>https://gqlgen.com/reference/complexity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/complexity/</guid><description>GraphQL provides a powerful way to query your data, but putting great power in the hands of your API clients also exposes you to a risk of denial of service attacks. You can mitigate that risk with gqlgen by limiting the complexity of the queries you allow.
Expensive Queries Consider a schema that allows listing blog posts. Each blog post is also related to other posts.
typeQuery{posts(count:Int=10):[Post!]!}typePost{title:String!text:String!related(count:Int=10):[Post!]!}It&amp;rsquo;s not too hard to craft a query that will cause a very large response:</description></item><item><title>Resolving graphQL requests</title><link>https://gqlgen.com/reference/resolvers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/resolvers/</guid><description>There are multiple ways that a graphQL type can be bound to a Go struct that allows for many usecases.
Bind directly to struct field names This is the most common use case where the names of the fields on the Go struct match the names of the fields in the graphQL type. If a Go struct field is unexported, it will not be bound to the graphQL type.
type Car struct { Make string Model string Color string OdometerReading int } And then in your graphQL schema:</description></item><item><title>Mapping GraphQL scalar types to Go types</title><link>https://gqlgen.com/reference/scalars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/scalars/</guid><description>Built-in helpers gqlgen ships with some built-in helpers for common custom scalar use-cases, Time, Any, Upload and Map. Adding any of these to a schema will automatically add the marshalling behaviour to Go types.
Time scalarTimeMaps a Time GraphQL scalar to a Go time.Time struct.
Map scalarMapMaps an arbitrary GraphQL value to a map[string]interface{} Go type.
Upload scalarUploadMaps a Upload GraphQL scalar to a graphql.Upload struct, defined as follows:
type Upload struct { File io.</description></item><item><title>Using schema directives to implement permission checks</title><link>https://gqlgen.com/reference/directives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gqlgen.com/reference/directives/</guid><description>Directives are a bit like annotations in any other language. They give you a way to specify some behaviour without directly binding to the implementation. This can be really useful for cross cutting concerns like permission checks.
Note: The current directives implementation is still fairly limited, and is designed to cover the most common &amp;ldquo;field middleware&amp;rdquo; case.
Declare it in the schema Directives are declared in your schema, along with all your other types.</description></item></channel></rss>